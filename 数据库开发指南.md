# RocksDB 数据库开发指南

本项目统一使用 **RocksDB** 作为核心存储引擎。这是一个高性能的嵌入式键值（Key-Value）数据库。

本文档将指导开发者如何在新的功能模块中正确、安全地使用数据库。

---

## 1. 核心模块引用

所有的数据库操作都封装在 `server/utils/rocksdb.js` 中。
在任何需要存储数据的文件中，请首先导入核心方法：

```javascript
import { put, get, del, getAll, getAllWithPrefix, NAMESPACES } from '../utils/rocksdb.js';
```

---

## 2. 命名空间 (Namespaces)

RocksDB 是 KV 数据库，为了防止 Key 冲突（例如：用户ID是 "1001"，订单ID也是 "1001"），我们使用 **Prefix (前缀)** 机制来隔离不同业务的数据。

我们称这种隔离为 **Namespace (命名空间)**。

### 现有命名空间
在 `rocksdb.js` 中查看 `NAMESPACES` 常量：
*   `users`: 用户数据
*   `orderBook`: 订单数据
*   `trades`: 成交记录
*   `predictionMarkets`: 预测市场
*   `predictionBets`: 预测下注
*   `history`: 历史记录
*   `system`: 系统配置（如时间、公告）
*   `homepage`: 首页缓存

### 如何新增命名空间
如果你开发的新模块需要存储全新类型的数据（例如："排行榜"），请先在 `rocksdb.js` 中注册：

```javascript
// server/utils/rocksdb.js
export const NAMESPACES = {
  // ... existing ...
  LEADERBOARD: 'leaderboard' // 新增
};
```

---

## 3. 基础 CRUD 操作

所有操作都是 **异步 (Async/Await)** 的。

### 3.1 写入数据 (Create / Update)
使用 `put(namespace, key, value)`。
*   `value` 可以是对象、数组或字符串，底层会自动 JSON 序列化。

```javascript
// 示例：保存排行榜数据
const saveScore = async (userId, scoreData) => {
  // Key: user_123, Value: { score: 100, time: ... }
  await put(NAMESPACES.LEADERBOARD, userId, {
    score: 100,
    timestamp: Date.now()
  });
  console.log('保存成功');
};
```

### 3.2 读取数据 (Read)
使用 `get(namespace, key)`。
*   如果 Key 不存在，返回 `null`。

```javascript
const getScore = async (userId) => {
  const data = await get(NAMESPACES.LEADERBOARD, userId);
  if (!data) {
    return 0; // 默认值
  }
  return data.score;
};
```

### 3.3 删除数据 (Delete)
使用 `del(namespace, key)`。

```javascript
const removeScore = async (userId) => {
  await del(NAMESPACES.LEADERBOARD, userId);
};
```

---

## 4. 高级查询

RocksDB 本身不支持 SQL 那样的 `WHERE` 查询，但支持高效的 **范围扫描**。

### 4.1 获取某命名空间下的所有数据
使用 `getAll(namespace)`。
*   返回数组：`[{ key: '...', value: ... }, ...]`

```javascript
const getAllScores = async () => {
  // 获取所有排行榜数据
  const allData = await getAll(NAMESPACES.LEADERBOARD);
  
  // 提取 value 并排序
  const scores = allData.map(item => item.value);
  return scores.sort((a, b) => b.score - a.score);
};
```

### 4.2 前缀搜索 (Prefix Scan)
如果你在一个命名空间下还有层级结构（例如 `logs:2024:01`, `logs:2024:02`），可以使用 `getAllWithPrefix`。

```javascript
// 获取 2024 年的所有日志
// 实际 Key 在数据库中是 "logs:2024:..."
const logs = await getAllWithPrefix('logs:2024');
```

---

## 5. 开发最佳实践 (Best Practices)

1.  **始终使用 `await`**: 数据库操作是 I/O 操作，必须等待完成，否则可能导致数据竞争或丢失。
2.  **不要在循环中频繁 `await put`**:
    *   ❌ 差评：循环 1000 次，每次 await 一次写入（极慢）。
    *   ✅ 好评：使用 `batch` 批量写入（`rocksdb.js` 中已封装 `batch` 方法，或自行实现并发）。
    ```javascript
    // 推荐：并行写入
    const tasks = users.map(u => put(NAMESPACES.USERS, u.id, u));
    await Promise.all(tasks);
    ```
3.  **Key 的设计很重要**:
    *   Key 是唯一的索引。
    *   建议格式：`{业务ID}`。
    *   如果需要按时间排序，可以将时间戳放在 Key 中吗？**不建议**，建议放在 Value 中，取出后在内存排序（除非数据量极大）。
4.  **数据迁移**:
    *   如果你的新功能需要从旧的 `.json` 文件迁移数据，请参考 `server/utils/homepageStorage.js` 中的 `initHomepageStorage` 模式：
        1.  检查 DB 是否有数据。
        2.  如果无，读取 JSON。
        3.  写入 DB。
        4.  重命名 JSON 为 `.bak`。

---

## 6. 常见错误排查

*   **错误**: `IO error: lock ...`
    *   **原因**: 试图同时打开两个 RocksDB 实例。通常是因为你在本地运行了服务器，同时又试图运行脚本去操作数据库。
    *   **解决**: 关闭正在运行的服务器，再运行脚本。RocksDB 是单进程锁定的。

*   **错误**: 读取到的数据是旧的
    *   **原因**: 忘记写 `await`，导致读取时写入尚未完成。
